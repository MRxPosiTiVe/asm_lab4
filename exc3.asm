.ORIG x3000

        ; Инициализация
        LD R2, INIT         ; Загрузка начального значения счетчика в R2
        LEA R1, ARRAY       ; Загрузка адреса начала массива в R1

        ; Ввод данных
        INPUT_LOOP
        ADD R2, R2, #1      ; Увеличение счетчика элементов массива
        LEA R0, INPUT_PROMPT ; Загрузка адреса строки приглашения ввода в R0
        PUTS                ; Вывод строки приглашения

        GETC                 ; Считывание символа с консоли
        OUT                  ; Вывод символа на консоль

        ADD R3, R0, #0       ; Копирование символа в R3
        LD R4, NEG_ASCII_ZERO ; Загрузка -48 в R4
        ADD R3, R3, R4        ; Преобразование символа в число
        STR R3, R1, #0       ; Сохранение числа в массиве
        ADD R1, R1, #1       ; Переход к следующему элементу

        LEA R0, NEWLINE      ; Загрузка символа новой строки
        PUTS                 ; Вывод новой строки

        ADD R3, R2, #-10     ; Проверка на завершение ввода
        BRz BUBBLE_SORT      ; Если введены все числа, переход к сортировке
        BRnzp INPUT_LOOP     ; Повторение ввода следующего символа

        ; Сортировка пузырьком
        BUBBLE_SORT
        LD R6, ARRAY_LEN     ; Загрузка длины массива в R6
        ADD R4, R6, #0       ; Копирование длины массива в R4 (для внешнего цикла)

        OUTER_LOOP
        ADD R4, R4, #-1      ; Уменьшение R4 на 1
        BRz OUTPUT_LOOP      ; Если R4 = 0, массив отсортирован
        LEA R3, ARRAY        ; Указатель на начало массива
        ADD R5, R4, #0       ; Копирование R4 в R5 (для внутреннего цикла)

        INNER_LOOP
        LDR R0, R3, #0       ; Загрузка текущего элемента
        LDR R1, R3, #1       ; Загрузка следующего элемента
        NOT R2, R1           ; Инверсия битов следующего элемента
        ADD R2, R2, #1       ; Инкрементация инвертированного значения
        ADD R2, R0, R2       ; R2 = R0 - R1
        BRN SWAP             ; Если R0 > R1, меняем местами
        SKIP_SWAP
        ADD R3, R3, #1       ; Переходим к следующему элементу
        ADD R5, R5, #-1      ; Уменьшение счетчика
        BRp INNER_LOOP       ; Повторение внутреннего цикла, если не все элементы проверены
        BRnzp OUTER_LOOP     ; Повторение внешнего цикла, если не все элементы отсортированы

        SWAP
        STR R1, R3, #0       ; Меняем элементы местами
        STR R0, R3, #1
        BRnzp SKIP_SWAP

        ; Вывод данных
        OUTPUT_LOOP
        LEA R1, ARRAY        ; Перезагрузка адреса начала массива
        LD R2, INIT          ; Сброс счетчика элементов

        PRINT_LOOP
        LDR R0, R1, #0       ; Загрузка элемента массива в R0
        LD R4, ASCII_ZERO    ; Загрузка ASCII-кода символа '0'
        ADD R0, R0, R4       ; Преобразование числа обратно в символ ASCII
        OUT                  ; Вывод символа
        LEA R0, NEWLINE      ; Загрузка символа новой строки
        PUTS                 ; Вывод новой строки
        ADD R1, R1, #1       ; Переход к следующему элементу
        ADD R2, R2, #1       ; Увеличение счетчика элементов
        ADD R3, R2, #-10     ; Проверка на конец вывода
        BRz END              ; Завершение программы, если все элементы выведены
        BRnzp PRINT_LOOP     ; Повторение вывода следующего элемента

        ; Завершение программы
        END
        HALT

        ; Константы и данные
        INIT .FILL #0         ; Начальное значение счетчика
        INPUT_PROMPT .STRINGZ "Enter a number: "
        NEWLINE .STRINGZ "\n" ; Символ новой строки
        ASCII_ZERO .FILL #48  ; ASCII-код символа '0'
        ARRAY .BLKW #10       ; Массив для хранения чисел
        ARRAY_LEN .FILL #10   ; Длина массива

        .END
